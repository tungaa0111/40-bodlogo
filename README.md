# 40-bodlogo
image
https://www.hackerrank.com/challenges/lilys-homework/problem?isFullScreen=true
Орчуулга
Жорж Лилигийн гэрийн даалгаврыг хийхэд туслахыг хүсдэг ч Лили гэрийн даалгавартаа завгүй байдаг. Жорж түүнд хурдан дуусгахад нь туслахыг хүсдэг, гэхдээ тэр энэ даалгаврыг ойлгоход хэцүү байна! Та Жоржийг Лилигийн гэрийн даалгаврыг ойлгоход нь тусалж болох уу? Өгөгдсөн нь ялгаатай бүхэл тоонуудын массив arrarr байна гэж үзье. Жорж массивын хоёр элементийг хүссэн тоогоор солих боломжтой. Массивыг "гоёмсог" гэж нэрлэх бөгөөд энэ нь массивын элементүүдийн эрэмбэлэгдсэн байдлын \sum |i - \text{erembeldegdsan index}|∑∣i−erembeldegdsan index∣-ийн нийлбэр хамгийн бага байхыг хэлнэ. Өгөгдсөн массивыг гоёмсог болгохын тулд хамгийн бага хэдэн удаа солих үйлдэл хийх шаардлагатайг олоод буцаана уу. Жишээ: Массивыг гоёмсог болгож болох нэг жишээ бол [3, 7, 12, 15][3,7,12,15] юм. Үүнийг авахын тулд Жорж дараах солилтуудыг хийсэн: Солих Үр дүн 3 \leftrightarrow 73↔7 [3, 15, 12, 7][3,15,12,7] 7 \leftrightarrow 157↔15 [3, 7, 12, 15][3,7,12,15] Гол нь гоёмсог массив болгохын тулд хамгийн багадаа 2 удаа солилт хийх хэрэгтэй болсон. Функцийн тодорхойлолт lilysHomework функцийг editor дотор бүрэн гүйцэд бичнэ үү. Параметрүүд: int arr[n]: бүхэл тооны массив Буцаах утга: int: хамгийн бага солилтын тоо Оролтын формат: Нэгдүгээр мөрөнд массивын элементийн тоо n Хоёрдугаар мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоон элементүүд байна.

image
https://www.hackerrank.com/challenges/sherlock-and-valid-string/problem?isFullScreen=true
Орчуулга:
Шерлок дараах нөхцлүүдийг хангаж байвал тэмдэгт мөрийг зөв (valid) гэж үздэг: Бүх тэмдэгт ижил тоогоор давтагдсан байх. Эсвэл зөвхөн нэг тэмдэгтийг хасахад үлдсэн тэмдэгтүүд бүгд ижил тоогоор давтагдаж байвал бас зөв гэж үзнэ. Танд нэг s тэмдэгт мөр өгөгдөнө. Энэ тэмдэгт мөрийг Шерлокийн дүрмээр зөв эсэхийг шалгаарай. Жишээ: abc: Бүх тэмдэгт 1 удаа гарч байна → YES abcc: Нэг c-г хасвал abc болно → бүгд 1 удаа гарч байгаа → YES aabbccddeefghi: Зөвхөн 1 тэмдэгтийг хасахад ч бүгд ижил болохгүй → NO Функцийн тайлбар: public static String isValid(String s) Параметр: s: тэмдэгт мөр (string) Буцаах утга: "YES" эсвэл "NO" гэж буцаана. Оролт (Input Format): Нэг мөр текст s, латин жижиг үсэгтэй тэмдэгт мөр байна.

image
https://www.hackerrank.com/challenges/sparse-arrays/problem?isFullScreen=true
#Тайлбар: Танд input мөрүүдийн цуглуулга болон query мөрүүдийн цуглуулга өгөгдсөн. Бүх query мөр бүрийн хувьд, тухайн мөр input жагсаалтанд хэдэн удаа давтагдсан байгааг олно. Үр дүнг массив (array) хэлбэрээр буцаа. Жишээ: input = ["abc", "def", "abc"] query = ["abc", "def", "gh"] "abc" 2 удаа, "def" 1 удаа, "gh" 0 удаа орсон байна. Тэгэхээр хариу нь: [2, 1, 0] Функцийн тодорхойлолт: List matchingStrings(List stringList, List queries) Параметрууд: stringList: Хайлт хийх үндсэн текстүүд (input мөрүүдийн жагсаалт) queries: Хайх хүсэлтүүдийн жагсаалт Буцаах утга: List: queries бүрт таарсан тоог агуулсан массив. Оролтын формат: Эхний мөр: n — stringList-ийн хэмжээ Дараагийн n мөр: тус бүр нь нэг stringList мөр Дараагийн мөр: q — queries-ийн хэмжээ Дараагийн q мөр: тус бүр нь нэг query мөр

image
https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem?isFullScreen=true
Тайлбар:
Холбоост жагсаалтад (linked list) цикл (давталт) байгаа эсэхийг шалгах Хэрэв жагсаалтыг нэг нэгээр дагаж үзэхэд ямар нэг node (зангилаа) хоёр удаа зочилогдож байвал, тухайн холбоост жагсаалтад цикл байна гэж үзнэ. Танд жагсаалтын эхлэл head заагч өгөгдсөн гэж үзье. Цикл байгаа эсэхийг тодорхойл. Хэрэв цикл байгаа бол → 1 буцаа. Хэрэв цикл байхгүй бол → 0 буцаа. Жишээ head нь дараах зангилаануудыг зааж байгаа гэж үзье: 0 → 1 → 2 → 3 → null Энэ нь эцсийн зангилаа null-д хүрч байна — цикл байхгүй, 0 буцаана. head нь дараах байдлаар зангилааг зааж байгаа гэж үзье: 0 → 1 → 2 → 3 ↘ ↖←←←←← Энд 3-р зангилаа буцаж 1-р зангилааг зааж байна — циклтэй, 1 буцаана. Функцийн тодорхойлолт int has_cycle(SinglyLinkedListNode head) Параметр: head — жагсаалтын эхлэл SinglyLinkedListNode төрлийн заагч. Буцаалт: int: 1 — хэрэв жагсаалт циклтэй бол 0 — хэрэв цикл байхгүй бол Оролтын формат: Код нь stdin-оос оролтыг авна. Энэ асуултанд хэрэглэгдэж буй custom test case-уудын формат тодорхойгүй (учир нь бага зэрэг төвөгтэй), гэхдээ хэрэв та хүсвэл main функцийн кодыг задлан хараад өөрийн test case-ийг хэрхэн үүсгэхийг ойлгож болно.

image
https://www.hackerrank.com/challenges/organizing-containers-of-balls/problem?isFullScreen=true
Асуулт:
Давид хэд хэдэн савтай бөгөөд эдгээр сав бүрт төрөл бүрийн бөмбөгнүүд байна. Тэрбээр байгаа бөмбөг бүрийг тус тусын төрөлд нь хуваарилахад яг тохирох тооны савтай. Давид бөмбөгнүүдийг дараах солилцоо хийх аргаар эмхэлж ангилахыг хүсэж байна: Шаардлага: Давид солилцоо хийхдээ дараах нөхцөлийг хангах ёстой: Сав бүр зөвхөн нэг төрлийн бөмбөг агуулна. Ижил төрлийн бөмбөг хоёр өөр саванд байх ёсгүй. Жишээ: Давид 2 сав, 2 төрлийн бөмбөгтэй байг. Сав дахь бөмбөгнүүдийн байршлыг доорх хүснэгтээр үзүүлж болно: 1 1
1 1 Энэ нь: 1-р сав: 1 ногоон, 1 улаан бөмбөг 2-р сав: 1 ногоон, 1 улаан бөмбөг Давид хоёр савнаас бөмбөг солих нэг үйлдэл хийж чадна (өөрөөр хэлбэл, хоёр өөр савнаас бөмбөг солино). Гэвч ийм солилцоогоор бүх ногоон бөмбөгийг нэг саванд, бүх улааныг нөгөөд нь хийж болохгүй. Иймд хариу нь Impossible (боломжгүй) байна. Ажиллагаа: Та хэд хэдэн container матриц хэлбэртэй асуултуудыг гүйцэтгэнэ. Матриц бүрт: container[i][j] нь i-р саванд байгаа j-р төрлийн бөмбөгний тоо байна. Матриц бүрийн хувьд дараах хариуг хэвлэнэ: Possible, хэрэв Давид бүх ижил төрлийн бөмбөгийг нэг саванд байрлуулж чадвал. Impossible, хэрэв боломжгүй бол. Функцийн тайлбар: String organizingContainers(List<List> container) Параметрүүд: container[n][m] – n ширхэг савны мэдээлэлтэй 2D массив. Тус бүрийн элементийн утга нь тухайн саванд байгаа төрлийн бөмбөгний тоо. Буцаах утга: String: “Possible” эсвэл “Impossible” Оролтын формат: Эхний мөр: q — асуултын тоо Дараагийн мөрүүд: тус бүр n × n хэмжээтэй матриц (savny тоо ба төрөл адил). Хязгаарлалт: Бөмбөгний тоо хэтэрхий их байхгүй (n ≤ 100) Сав бүр өөр төрөл бөмбөг агуулахгүй нөхцлийг солилцоогоор хангаж чадах эсэхийг шалгана.

image
https://www.hackerrank.com/challenges/encryption/problem?isFullScreen=true
Шифрлэх даалгаврын орчуулга:
Англи текстийг дараах шифрлэх схем ашиглан шифрлэх шаардлагатай. Эхлээд текст доторх бүх зай (space)-г устгана. Дараа нь тэмдэгтүүдийг нэгэн төрлийн мөр, баганын хязгаарлалттай сүлжээнд (grid) байрлуулна. Жишээ: Жишээ нь, доорх текст өгөгдсөн бол: if man was meant to stay on the ground god would have given us roots Spaces-ийг устгасны дараа: ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots Энэ нь 54 тэмдэгттэй. Тэгвэл: L = 54 floor(sqrt(L)) = 7 ceil(sqrt(L)) = 8 → 7 ≤ rows ≤ columns ≤ 8 гэсэн нөхцлийг хангах хамгийн бага rows * columns талбайтай grid нь 7 мөр, 8 багана байна. Grid-д оруулбал: ifmanwas meanttos tayonthe groundgo dwouldha vegivenu sroots Шифрлэгдсэн үр дүн: Баганаар дараалан тэмдэгтүүдийг авч, хооронд нь зайтай бичнэ: imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau ✅ Функцийн тайлбар: encryption гэдэг функц нь дараах параметртэй: Параметр: string s – шифрлэх англи текст Буцаах утга: string – шифрлэгдсэн текст ✅ Оролтын формат: Нэг мөрөнд шифрлэх текст өгөгдөнө. Зөвхөн жижиг үсгүүд (a–z) болон зай (space, ascii 32) агуулагдана.

image
https://www.hackerrank.com/challenges/bigger-is-greater/problem?isFullScreen=true
Орчуулга:
Лексикографик дараалал гэдэг нь ихэвчлэн үсгийн дараалал гэж ойлгогддог. Хоёр үгийн аль нь их вэ гэдгийг тодорхойлоход, илүү дараа нь ирдэг үгийг илүү их гэж үзнэ. Танд нэг үг өгөгдөнө. Та энэ үгийн зарим эсвэл бүх үсгийг сольж шинэ үг үүсгэх хэрэгтэй. Шинэ үг дараах хоёр нөхцөлийг хангасан байх ёстой: Шинэ үг нь анхны үгээс их байх ёстой (лексикографикаар дараа нь байх). Тэр их үгнүүдээс хамгийн бага буюу хамгийн ойр дараагийн үг байх ёстой. Жишээ: Жишээ үг: ab Дараагийн хамгийн бага их үг: ba 🔧 Функцийн тайлбар: String biggerIsGreater(String w) Параметр: w: нэг үг (string) Буцаах утга: Хэрвээ боломжтой бол: анхны үгнээс лексикографикаар их, хамгийн бага боломжит шинэ үгийг буцаана. Боломжгүй бол: "no answer" гэдэг текст буцаана. 🧾 Оролтын формат: Эхний мөрөнд: T — тестийн тоо (integer) Дараагийн T мөрөнд: үгнүүд (w) байна ⛔️ Хязгаарлалт: Үг нь зөвхөн жижиг үсгүүд ascii[a..z] агуулсан байна.


image
https://www.hackerrank.com/challenges/two-pluses/problem?isFullScreen=true
Эмма квант компьютер бүтээжээ!
Түүний чадварыг шалгахад туслаарай, доорх бодлогыг шийднэ үү:

🧩 Бодлогын тайлбар: Өгөгдсөн n × m хэмжээтэй тор (grid) байна. Энэ торны бүх нүд G эсвэл B тэмдэгттэй байна: G — сайн (green) нүд, энд plus зурах боломжтой. B — муу (bad) нүд, энд юу ч зурах боломжгүй. ➕ "Plus" гэж юу вэ? Plus (нэмэх тэмдэг) гэдэг нь гол нүд-нээс дээш, доош, зүүн, баруун чиглэлд ижил урттай "гар" сунгасан хэлбэр юм. Жишээлбэл: G GGGGG G Энэ нь голдоо G тэмдэгтэй, тал бүрт 2 урттай гартай size = 2 plus юм. Нийт талбай: 4 * size + 1 = 9. 🎯 Зорилго: 2 ширхэг "plus" ол. Эдгээр нь давхцахгүй байх ёстой (аль ч нүд давхардахгүй). Тэдгээрийн талбайн үржвэр хамгийн их байх ёстой. Жишээ: Хоёр plus: нэг нь 9 талбай, нөгөө нь 5 талбай. Үржвэр: 9 * 5 = 45. ⚙️ Функцийн тодорхойлолт: int twoPluses(List grid) Параметрүүд: grid: мөрүүдийн жагсаалт. Бүх тэмдэгт G эсвэл B. ⌨️ Оролтын формат: Эхний мөрөнд 2 бүхэл тоо байна — n ба m. Дараагийн n мөр бүрт m ширхэг тэмдэгттэй string байна. 🧾 Гаралтын формат: Хамгийн том 2 plus-н талбайн үржвэрийг нэг бүхэл тоогоор хэвлэ. 🧷 Хязгаарлалт: 2 ≤ n, m ≤ 15

image
https://www.hackerrank.com/challenges/larrys-array/problem?isFullScreen=true
Орчуулга
Ларриг 1-ээс эхэлсэн дарааллын нэгэн орлуулгыг массив хэлбэрээр өгсөн. Тэрээр дараах үйлдлийг хэдэн ч удаа давтаж массивыг эрэмбэлж болох эсэхийг тодорхойлох ёстой: Үргэлжлүүлэн байрласан ямар нэгэн 3 индексийг сонгож, эдгээр гурван элементүүдийг тойруулан эргүүлэх (rotation) үйлдлийг хийх. Жишээ нь: A эргүүлэлт [1,6,5,2,4,3] [6,5,2] [1,5,2,6,4,3] [5,2,6] [1,2,6,5,4,3] [5,4,3] [1,2,6,3,5,4] [6,3,5] [1,2,3,5,6,4] [5,6,4] [1,2,3,4,5,6] Хэрэв бүх элементүүдийг эрэмбэлж чадвал (sorted array) "YES" гэж хэвлэ, үгүй бол "NO" гэж хэвлэ. Функцийн тайлбар larrysArray функц нь массив A-г параметр болгон авч, "YES" эсвэл "NO" утгыг буцаана. Оролтын формат Эхний мөрөнд туршилтын тоо t байна. Дараагийн t хос мөр бүр: Нэг мөрөнд массивын урт n Дараагийн мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоон элементүүд өгөгдөнө. Хязгаарлалт Массивын элементүүд 1-ээс n хүртэл тасралтгүй өссөн тоонууд байна. Гаралтын формат Туршилтын бүрд нэг мөрөнд "YES" эсвэл "NO" гэж хэвлэнэ.

image
https://www.hackerrank.com/challenges/almost-sorted/problem?isFullScreen=true
ОРчуулга
Өгөгдсөн бүхэл тооны массивыг зөвхөн дараах нэг үйлдлээр өсөх дарааллаар эрэмбэлж болох эсэхийг тодорхойлно уу: Хоёр элементийг солино. Нэг тасалбар хэсгийг буцааж эргүүлнэ. Үйлдлүүдийн аль нэгийг ашиглан массивыг эрэмбэлж болдог эсэхийг шалгаад, үр дүнг дараах байдлаар гаргана: Хэрвээ массив аль хэдийнээ эрэмбэлэгдсэн байвал, эхний мөрөнд yes гэж хэвлэ. Дараагийн мөрийг хэвлэх шаардлагагүй. Хэрвээ массивыг зөвхөн нэг үйлдлээр эрэмбэлж болдог бол, эхний мөрөнд yes гэж хэвлээд дараах байдлаар үргэлжлүүлнэ: Хэрвээ зөвхөн хоёр элементийг солих замаар л эрэмбэлж болох бол, хоёр дахь мөрөнд swap l r гэж хэвлэнэ. Энд l ба r нь солино гэж байгаа элементүүдийн индекс бөгөөд массивын индекс 1-ээс эхэлнэ гэж үзнэ. Харин зөвхөн тасалбар хэсгийг буцааж эргүүлэх замаар л эрэмбэлж болох бол, хоёр дахь мөрөнд reverse l r гэж хэвлэнэ. Энд l ба r нь эргүүлэх тасалбар хэсгийн эхний ба сүүлийн элементүүдийн индекс (1-ээс эхлэх) болно. Хэрвээ массивыг солих болон эргүүлэх аль аль үйлдлээр эрэмбэлж болдог бол, заавал солих (swap) үйлдлийг сонгоно. Хэрвээ массивыг эдгээр үйлдлүүдийн аль нэгээр ч эрэмбэлж болдоггүй бол эхний мөрөнд no гэж хэвлэнэ. Жишээ Массивыг эрэмбэлэхийн тулд 3 болон 4-р индекст байгаа элементийг солих буюу эсвэл тэдгээрийг буцааж эргүүлэх боломжтой. Өмнө дурдсанчлан солих үйлдлийг илүүд үздэг тул: Эхний мөрөнд: yes Хоёр дахь мөрөнд: swap 3 4 гэж хэвлэнэ. Функцийн тайлбар almostSorted функц нь дараах параметртэй: arr: бүхэл тооны массив (int arr[n]) Функц нь үр дүнг хэвлэх бөгөөд юу ч буцаахгүй. Оролтын формат Эхний мөрөнд массивын урт n байна. Дараагийн мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоо байна. Хязгаарлалт Бүх элементүүд өөр хоорондоо ялгаатай байна. Гаралтын формат Хэрвээ массив аль хэдийн эрэмбэлэгдсэн бол, эхний мөрөнд yes гэж хэвлэнэ. Хэрвээ нэг үйлдлээр массивыг эрэмбэлж болдог бол эхний мөрөнд yes гэж, хоёр дахь мөрөнд swap l r эсвэл reverse l r гэж хэвлэнэ. Хэрвээ эрэмбэлж чадахгүй бол no гэж хэвлэнэ.


image
https://www.hackerrank.com/challenges/countingsort4/problem?isFullScreen=true
Орчуулга
Тодорхойлолт: Тоон утгатай холбогдсон тэмдэгтүүдийн жагсаалтыг тоологч сорт (counting sort) аргаар эрэмбэлнэ үү. Хоёр тэмдэгт ижил тоотой холбогдсон бол эхний орох дарааллаараа хэвээр хэвлэгдэх ёстой, үүний тулд таны сортын алгоритм тогтвортой (stable) байх ёстой. Нэг өөр онцлог нь: массивын эхний хагас дахь тэмдэгтүүдийг "-" (тире) тэмдэгтээр орлуулах шаардлагатай. Оршил: Оруулах сорт (Insertion Sort) болон энгийн хувилбарын Quicksort тогтвортой байдаг. Харин хурдан хувилбарын, inplace Quicksort тогтвортой биш, учир нь элементүүдийг холино. Та тогтвортой тоологч сорт зохион бүтээх хэрэгтэй. Жишээ: Эхний хоёр тэмдэгтийг "-" болгон орлуулна. Хамгийн их тоо нь 2 гэж үзвэл, доорх шиг туслах массив (багц) 3 хоосон жагсаалтаас бүрдэх болно. i тэмдэгт орлуулсан утга жагсаалт 0 [[], [], []] 1 a - [["-"], [], []] 2 b - [["-"], ["-"], []] 3 c c [["-", "c"], ["-"], []] 4 d d [["-", "c"], ["-", "d"], []] Дараа нь жагсаалтыг хэвлэнэ: - - c d Функцийн тодорхойлолт: countSort функцийг бүрэн гүйцэд бичнэ үү. Аргумент нь: string arr[n][2] — n хос утга бүхий массив, arr[i] нь x (тоо-string хэлбэрээр) болон s (тэмдэгт мөр) байна. Үр дүн: Эцсийн эрэмбэлсэн тэмдэгтүүдийг нэг мөрөнд хооронд нь нэг зайгаар тусгаарлан хэвлэнэ. Оролтын формат: Эхний мөрөнд n — хос утгын тоо Дараагийн n мөрөнд x ба s байна. x нь string хэлбэрийн тоо, s нь тэмдэгт мөр. Хязгаарлалтууд: n нь тэгш тоо байна. s нь ASCII тэмдэгтүүдийн хүрээнд оршино. Гаралт формат: Эрэмбэлсэн тэмдэгтүүдийг зайгаар тусгаарлан нэг мөрөнд хэвлэнэ.

image
https://www.hackerrank.com/challenges/fraudulent-activity-notifications/problem?isFullScreen=true
Орчуулга
HackerLand Үндэсний Банк нь үйлчлүүлэгчдэд хуурамч үйл ажиллагааны эрсдэл байж болзошгүй талаар сэрэмжлүүлэх энгийн дүрэмтэй. Хэрэв тухайн өдөр үйлчлүүлэгчийн зарцуулсан хэмжээ нь өмнөх тодорхой тооны өдрийн дундаж зарцуулалтаас их буюу тэнцүү бол банк үйлчлүүлэгчид ийм эрсдэлтэй талаар мэдэгдэл илгээдэг. Гэхдээ банк тухайн тооны өдрийн өмнөх өгөгдөл бүрэн цуглартал мэдэгдэл илгээдэггүй. Таны даалгавар бол өгөгдсөн өмнөх өдрийн тоо d болон тухайн үйлчлүүлэгчийн нийт өдөр тутмын зарцуулалтын өгөгдөлд үндэслэн нийт хэдэн удаа мэдэгдэл илгээгдэхийг тодорхойлох юм. Жишээ: Эхний гурван өдөр банк зөвхөн өгөгдөл цуглуулна. 4 дэх өдөр өмнөх 3 өдрийн зарцуулалт [10, 20, 30] байна. Тус хугацааны дундаж нь 20 бөгөөд тухайн өдрийн зарцуулалт 40 байна. Учир нь 40 >= 220 тул мэдэгдэл илгээгдэнэ. Дараагийн өдөр өмнөх 3 өдрийн зарцуулалт [20,30,40], өдөр тутмын зарцуулалт 50 байна. Гэвч 50 < 230 тул мэдэгдэл илгээгдэхгүй. Нийт хугацаанд нэг мэдэгдэл илгээгдсэн байна. Анхаар: Дундажийг олохдоо өгөгдлийг өсөх дарааллаар эрэмбэлнэ. Хэрвээ өгөгдлийн тоо тэгш бол хоёр дунд утгын дундажийг авна, сондгой бол яг дунд утгыг сонгоно. Функцийн тайлбар: activityNotifications функцийг бүрэн гүйцэд бичнэ үү. Параметрүүд: int expenditure[n]: өдөр тутмын зарцуулалт int d: дундажийг тооцох өмнөх өдрийн тоо Буцах утга: int: нийт илгээсэн мэдэгдлийн тоо Оролтын формат: Эхний мөрөнд хоёр орон зайгаар тусгаарлагдсан бүхэл тоо n болон d байна. Хоёр дахь мөрөнд n ширхэг 0 болон түүнээс дээш бүхэл тоо өгөгдөнө. Эдгээр нь өдөр тутмын зарцуулалтыг илэрхийлнэ.

image
https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem?isFullScreen=true
Тайлбар:
Холбоост жагсаалтад (linked list) цикл (давталт) байгаа эсэхийг шалгах Хэрэв жагсаалтыг нэг нэгээр дагаж үзэхэд ямар нэг node (зангилаа) хоёр удаа зочилогдож байвал, тухайн холбоост жагсаалтад цикл байна гэж үзнэ. Танд жагсаалтын эхлэл head заагч өгөгдсөн гэж үзье. Цикл байгаа эсэхийг тодорхойл. Хэрэв цикл байгаа бол → 1 буцаа. Хэрэв цикл байхгүй бол → 0 буцаа. Жишээ head нь дараах зангилаануудыг зааж байгаа гэж үзье: 0 → 1 → 2 → 3 → null Энэ нь эцсийн зангилаа null-д хүрч байна — цикл байхгүй, 0 буцаана. head нь дараах байдлаар зангилааг зааж байгаа гэж үзье: 0 → 1 → 2 → 3 ↘ ↖←←←←← Энд 3-р зангилаа буцаж 1-р зангилааг зааж байна — циклтэй, 1 буцаана. Функцийн тодорхойлолт int has_cycle(SinglyLinkedListNode head) Параметр: head — жагсаалтын эхлэл SinglyLinkedListNode төрлийн заагч. Буцаалт: int: 1 — хэрэв жагсаалт циклтэй бол 0 — хэрэв цикл байхгүй бол Оролтын формат: Код нь stdin-оос оролтыг авна. Энэ асуултанд хэрэглэгдэж буй custom test case-уудын формат тодорхойгүй (учир нь бага зэрэг төвөгтэй), гэхдээ хэрэв та хүсвэл main функцийн кодыг задлан хараад өөрийн test case-ийг хэрхэн үүсгэхийг ойлгож болно.

image
https://www.hackerrank.com/challenges/tree-huffman-decoding/problem?isFullScreen=true
Huffman кодчилол гэж юу вэ?
Huffman кодчилол нь тогтмол урттай оролтын тэмдэгтүүдэд хувьсах урттай код үг оноодог аргаар ажилладаг. Их давтамжтай тэмдэгтүүд → богино код Бага давтамжтай тэмдэгтүүд → урт код авдаг. Модыг бүтээхдээ: Зүүн тийш бол 0 Баруун тийш бол 1 гэж тэмдэглэнэ. Навч (leaf) дээр л тэмдэгт болон давтамж хадгалагдана. Бусад дотоод node-ууд тэмдэгт биш, зөвхөн frequency-ийн нийлбэр хадгална. 📚 Жишээ: Тэмдэгт мөр: ABRACADABRA Нийт тэмдэгт: 11 ширхэг. Давтамжууд: A – 5 B – 2 R – 2 C – 1 D – 1 Бага давтамжтай C ба D-г модны доод түвшинд холбож эхэлнэ. Дараа нь давтамжийн дарааллаар модыг үргэлжлүүлэн холбож Huffman мод үүсгэнэ. 📌 Тэмдэгтүүдийн код: Тэмдэгт Код A 0 B 111 C 1100 D 1101 R 10 📥 Huffman кодлогдсон тэмдэгт мөр: Жишээ: A B R A C A D A B R A → 0 111 10 0 1100 0 1101 0 111 10 0 Энэ нь нэг мөрт: 01111001100011010111100 🚫 Хоорондоо зөрчилдөхөөс сэргийлэх (Prefix-free): Huffman код нь prefix-free гэж нэрлэгддэг. → Аль ч тэмдэгтийн код нь өөр тэмдэгтийн кодын эхлэл байж болохгүй. → Иймээс кодыг унагдалгүй буцааж тайлж унших боломжтой. 🔧 Функцын тайлбар: decode_huff функц: root: Huffman модны үндэс s: кодлогдсон binary string (жишээ нь: 01111001100011010111100) Хийх ажил: Модыг даган s-ийг тайлж эх хэлбэрээр буцаана/гаргана

image
https://www.hackerrank.com/challenges/swap-nodes-algo/problem?isFullScreen=true
Хоёртын модны тухай
Хоёртын мод (Binary Tree) гэдэг нь дараах шинж чанаруудын аль нэгтэй мод юм: Хоосон байж болно (null). Зөвхөн үндэс (root) зангилаатай байж болно. Үндэс зангилаатай бөгөөд зүүн, баруун эсвэл хоёулантай нь дэд модтой байж болно. Эдгээр дэд моднууд нь мөн хоёртын мод байна. 🔁 In-order (дэс дараалалтай) гүйцэтгэл In-order гүйцэтгэлийг дараах дарааллаар хийнэ: Зүүн дэд модыг гүйцэтгэнэ. Үндэс зангилааг зочилно (өгөгдлийг хадгална). Баруун дэд модыг гүйцэтгэнэ. Гүйцэтгэхдээ: Үндэсийн зүүн хүүхдээс эхэлж, дэд мод руу нь орно. Навч хүрвэл буцаж эцэг зангилаа руу очно. Баруун хүүхэд байгаа эсэхийг шалгана. Байвал түүгээр үргэлжлүүлнэ. Ингэсээр модыг бүхэлд нь гүйцэтгэнэ. Зангилааны утгыг дараах тохиолдлуудад хадгална: Эхний удаа зочилсон зангилаа бол Навч зангилаа бол (зөвхөн нэг удаа зочилно) Дэд моднууд нь бүрэн гүйцэтгэгдсэн бол Үндэс зангилаа бол (эхний удаа зочилно) 🔁 Солилт хийх (Swapping) Зангилааны дэд модыг солих гэдэг нь: Хэрвээ зүүн дэд мод нь L, баруун дэд мод нь R бол Солилтын дараа зүүн нь R, баруун нь L болно. Жишээ: Гүн 1 1 [1] / \ /
2 3 => 3 2 [2] \ \ \
4 5 5 4 [3] Зүүн модны in-order: 2 4 1 3 5 Баруун модны in-order: 3 5 1 2 4 🔁 Солилтын үйлдэл: Зангилааны гүнийг дараах байдлаар тодорхойлно: Үндэс зангилаа — гүн 1 Хэрвээ эцэг зангилааны гүн нь d бол, хүүхдийнх нь гүн d+1 байна. Танд мод өгөгдсөн бөгөөд integer k байна. Та гүний түвшин h-д байгаа бүх зангилааны зүүн, баруун дэд модыг сольж гүйцэтгэх ёстой. h нь k, 2k, 3k, ... гэх мэт k-ийн үржвэрүүд байна. Нэг k-д нэг swap. Танд t ширхэг k утгууд өгөгдөнө. 🔧 Функцийн тодорхойлолт swapNodes(indexes, queries) ✅ Параметрүүд: indexes: Модны зангилаа бүрийн зүүн, баруун хүүхдийн индексүүдийн 2D массив. Эхний элемент нь үндэс. -1 гэдэг нь null буюу хүүхэд байхгүй гэсэн утга. queries: t ширхэг k утгууд. 📥 Оролтын формат: n ← зангилааны тоо a1 b1 ← 1-р зангилааны зүүн, баруун хүүхэд a2 b2 ← 2-р зангилааны ... ... an bn t ← queries-ийн тоо k1 k2 ... kt 📤 Гаралтын формат: t ширхэг мөр гарна. Тухайн k-д харгалзах swap хийсний дараах in-order гүйцэтгэлийн үр дүн буюу зангилааны индексүүд нэг мөрөнд хэвлэгдэнэ.


