# 40-bodlogo
image
https://www.hackerrank.com/challenges/lilys-homework/problem?isFullScreen=true
Орчуулга
Жорж Лилигийн гэрийн даалгаврыг хийхэд туслахыг хүсдэг ч Лили гэрийн даалгавартаа завгүй байдаг. Жорж түүнд хурдан дуусгахад нь туслахыг хүсдэг, гэхдээ тэр энэ даалгаврыг ойлгоход хэцүү байна! Та Жоржийг Лилигийн гэрийн даалгаврыг ойлгоход нь тусалж болох уу? Өгөгдсөн нь ялгаатай бүхэл тоонуудын массив arrarr байна гэж үзье. Жорж массивын хоёр элементийг хүссэн тоогоор солих боломжтой. Массивыг "гоёмсог" гэж нэрлэх бөгөөд энэ нь массивын элементүүдийн эрэмбэлэгдсэн байдлын \sum |i - \text{erembeldegdsan index}|∑∣i−erembeldegdsan index∣-ийн нийлбэр хамгийн бага байхыг хэлнэ. Өгөгдсөн массивыг гоёмсог болгохын тулд хамгийн бага хэдэн удаа солих үйлдэл хийх шаардлагатайг олоод буцаана уу. Жишээ: Массивыг гоёмсог болгож болох нэг жишээ бол [3, 7, 12, 15][3,7,12,15] юм. Үүнийг авахын тулд Жорж дараах солилтуудыг хийсэн: Солих Үр дүн 3 \leftrightarrow 73↔7 [3, 15, 12, 7][3,15,12,7] 7 \leftrightarrow 157↔15 [3, 7, 12, 15][3,7,12,15] Гол нь гоёмсог массив болгохын тулд хамгийн багадаа 2 удаа солилт хийх хэрэгтэй болсон. Функцийн тодорхойлолт lilysHomework функцийг editor дотор бүрэн гүйцэд бичнэ үү. Параметрүүд: int arr[n]: бүхэл тооны массив Буцаах утга: int: хамгийн бага солилтын тоо Оролтын формат: Нэгдүгээр мөрөнд массивын элементийн тоо n Хоёрдугаар мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоон элементүүд байна.

image
https://www.hackerrank.com/challenges/sherlock-and-valid-string/problem?isFullScreen=true
Орчуулга:
Шерлок дараах нөхцлүүдийг хангаж байвал тэмдэгт мөрийг зөв (valid) гэж үздэг: Бүх тэмдэгт ижил тоогоор давтагдсан байх. Эсвэл зөвхөн нэг тэмдэгтийг хасахад үлдсэн тэмдэгтүүд бүгд ижил тоогоор давтагдаж байвал бас зөв гэж үзнэ. Танд нэг s тэмдэгт мөр өгөгдөнө. Энэ тэмдэгт мөрийг Шерлокийн дүрмээр зөв эсэхийг шалгаарай. Жишээ: abc: Бүх тэмдэгт 1 удаа гарч байна → YES abcc: Нэг c-г хасвал abc болно → бүгд 1 удаа гарч байгаа → YES aabbccddeefghi: Зөвхөн 1 тэмдэгтийг хасахад ч бүгд ижил болохгүй → NO Функцийн тайлбар: public static String isValid(String s) Параметр: s: тэмдэгт мөр (string) Буцаах утга: "YES" эсвэл "NO" гэж буцаана. Оролт (Input Format): Нэг мөр текст s, латин жижиг үсэгтэй тэмдэгт мөр байна.

image
https://www.hackerrank.com/challenges/sparse-arrays/problem?isFullScreen=true
#Тайлбар: Танд input мөрүүдийн цуглуулга болон query мөрүүдийн цуглуулга өгөгдсөн. Бүх query мөр бүрийн хувьд, тухайн мөр input жагсаалтанд хэдэн удаа давтагдсан байгааг олно. Үр дүнг массив (array) хэлбэрээр буцаа. Жишээ: input = ["abc", "def", "abc"] query = ["abc", "def", "gh"] "abc" 2 удаа, "def" 1 удаа, "gh" 0 удаа орсон байна. Тэгэхээр хариу нь: [2, 1, 0] Функцийн тодорхойлолт: List matchingStrings(List stringList, List queries) Параметрууд: stringList: Хайлт хийх үндсэн текстүүд (input мөрүүдийн жагсаалт) queries: Хайх хүсэлтүүдийн жагсаалт Буцаах утга: List: queries бүрт таарсан тоог агуулсан массив. Оролтын формат: Эхний мөр: n — stringList-ийн хэмжээ Дараагийн n мөр: тус бүр нь нэг stringList мөр Дараагийн мөр: q — queries-ийн хэмжээ Дараагийн q мөр: тус бүр нь нэг query мөр

image
https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem?isFullScreen=true
Тайлбар:
Холбоост жагсаалтад (linked list) цикл (давталт) байгаа эсэхийг шалгах Хэрэв жагсаалтыг нэг нэгээр дагаж үзэхэд ямар нэг node (зангилаа) хоёр удаа зочилогдож байвал, тухайн холбоост жагсаалтад цикл байна гэж үзнэ. Танд жагсаалтын эхлэл head заагч өгөгдсөн гэж үзье. Цикл байгаа эсэхийг тодорхойл. Хэрэв цикл байгаа бол → 1 буцаа. Хэрэв цикл байхгүй бол → 0 буцаа. Жишээ head нь дараах зангилаануудыг зааж байгаа гэж үзье: 0 → 1 → 2 → 3 → null Энэ нь эцсийн зангилаа null-д хүрч байна — цикл байхгүй, 0 буцаана. head нь дараах байдлаар зангилааг зааж байгаа гэж үзье: 0 → 1 → 2 → 3 ↘ ↖←←←←← Энд 3-р зангилаа буцаж 1-р зангилааг зааж байна — циклтэй, 1 буцаана. Функцийн тодорхойлолт int has_cycle(SinglyLinkedListNode head) Параметр: head — жагсаалтын эхлэл SinglyLinkedListNode төрлийн заагч. Буцаалт: int: 1 — хэрэв жагсаалт циклтэй бол 0 — хэрэв цикл байхгүй бол Оролтын формат: Код нь stdin-оос оролтыг авна. Энэ асуултанд хэрэглэгдэж буй custom test case-уудын формат тодорхойгүй (учир нь бага зэрэг төвөгтэй), гэхдээ хэрэв та хүсвэл main функцийн кодыг задлан хараад өөрийн test case-ийг хэрхэн үүсгэхийг ойлгож болно.

image
https://www.hackerrank.com/challenges/organizing-containers-of-balls/problem?isFullScreen=true
Асуулт:
Давид хэд хэдэн савтай бөгөөд эдгээр сав бүрт төрөл бүрийн бөмбөгнүүд байна. Тэрбээр байгаа бөмбөг бүрийг тус тусын төрөлд нь хуваарилахад яг тохирох тооны савтай. Давид бөмбөгнүүдийг дараах солилцоо хийх аргаар эмхэлж ангилахыг хүсэж байна: Шаардлага: Давид солилцоо хийхдээ дараах нөхцөлийг хангах ёстой: Сав бүр зөвхөн нэг төрлийн бөмбөг агуулна. Ижил төрлийн бөмбөг хоёр өөр саванд байх ёсгүй. Жишээ: Давид 2 сав, 2 төрлийн бөмбөгтэй байг. Сав дахь бөмбөгнүүдийн байршлыг доорх хүснэгтээр үзүүлж болно: 1 1
1 1 Энэ нь: 1-р сав: 1 ногоон, 1 улаан бөмбөг 2-р сав: 1 ногоон, 1 улаан бөмбөг Давид хоёр савнаас бөмбөг солих нэг үйлдэл хийж чадна (өөрөөр хэлбэл, хоёр өөр савнаас бөмбөг солино). Гэвч ийм солилцоогоор бүх ногоон бөмбөгийг нэг саванд, бүх улааныг нөгөөд нь хийж болохгүй. Иймд хариу нь Impossible (боломжгүй) байна. Ажиллагаа: Та хэд хэдэн container матриц хэлбэртэй асуултуудыг гүйцэтгэнэ. Матриц бүрт: container[i][j] нь i-р саванд байгаа j-р төрлийн бөмбөгний тоо байна. Матриц бүрийн хувьд дараах хариуг хэвлэнэ: Possible, хэрэв Давид бүх ижил төрлийн бөмбөгийг нэг саванд байрлуулж чадвал. Impossible, хэрэв боломжгүй бол. Функцийн тайлбар: String organizingContainers(List<List> container) Параметрүүд: container[n][m] – n ширхэг савны мэдээлэлтэй 2D массив. Тус бүрийн элементийн утга нь тухайн саванд байгаа төрлийн бөмбөгний тоо. Буцаах утга: String: “Possible” эсвэл “Impossible” Оролтын формат: Эхний мөр: q — асуултын тоо Дараагийн мөрүүд: тус бүр n × n хэмжээтэй матриц (savny тоо ба төрөл адил). Хязгаарлалт: Бөмбөгний тоо хэтэрхий их байхгүй (n ≤ 100) Сав бүр өөр төрөл бөмбөг агуулахгүй нөхцлийг солилцоогоор хангаж чадах эсэхийг шалгана.

image
https://www.hackerrank.com/challenges/encryption/problem?isFullScreen=true
Шифрлэх даалгаврын орчуулга:
Англи текстийг дараах шифрлэх схем ашиглан шифрлэх шаардлагатай. Эхлээд текст доторх бүх зай (space)-г устгана. Дараа нь тэмдэгтүүдийг нэгэн төрлийн мөр, баганын хязгаарлалттай сүлжээнд (grid) байрлуулна. Жишээ: Жишээ нь, доорх текст өгөгдсөн бол: if man was meant to stay on the ground god would have given us roots Spaces-ийг устгасны дараа: ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots Энэ нь 54 тэмдэгттэй. Тэгвэл: L = 54 floor(sqrt(L)) = 7 ceil(sqrt(L)) = 8 → 7 ≤ rows ≤ columns ≤ 8 гэсэн нөхцлийг хангах хамгийн бага rows * columns талбайтай grid нь 7 мөр, 8 багана байна. Grid-д оруулбал: ifmanwas meanttos tayonthe groundgo dwouldha vegivenu sroots Шифрлэгдсэн үр дүн: Баганаар дараалан тэмдэгтүүдийг авч, хооронд нь зайтай бичнэ: imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau ✅ Функцийн тайлбар: encryption гэдэг функц нь дараах параметртэй: Параметр: string s – шифрлэх англи текст Буцаах утга: string – шифрлэгдсэн текст ✅ Оролтын формат: Нэг мөрөнд шифрлэх текст өгөгдөнө. Зөвхөн жижиг үсгүүд (a–z) болон зай (space, ascii 32) агуулагдана.

image
https://www.hackerrank.com/challenges/bigger-is-greater/problem?isFullScreen=true
Орчуулга:
Лексикографик дараалал гэдэг нь ихэвчлэн үсгийн дараалал гэж ойлгогддог. Хоёр үгийн аль нь их вэ гэдгийг тодорхойлоход, илүү дараа нь ирдэг үгийг илүү их гэж үзнэ. Танд нэг үг өгөгдөнө. Та энэ үгийн зарим эсвэл бүх үсгийг сольж шинэ үг үүсгэх хэрэгтэй. Шинэ үг дараах хоёр нөхцөлийг хангасан байх ёстой: Шинэ үг нь анхны үгээс их байх ёстой (лексикографикаар дараа нь байх). Тэр их үгнүүдээс хамгийн бага буюу хамгийн ойр дараагийн үг байх ёстой. Жишээ: Жишээ үг: ab Дараагийн хамгийн бага их үг: ba 🔧 Функцийн тайлбар: String biggerIsGreater(String w) Параметр: w: нэг үг (string) Буцаах утга: Хэрвээ боломжтой бол: анхны үгнээс лексикографикаар их, хамгийн бага боломжит шинэ үгийг буцаана. Боломжгүй бол: "no answer" гэдэг текст буцаана. 🧾 Оролтын формат: Эхний мөрөнд: T — тестийн тоо (integer) Дараагийн T мөрөнд: үгнүүд (w) байна ⛔️ Хязгаарлалт: Үг нь зөвхөн жижиг үсгүүд ascii[a..z] агуулсан байна.


image
https://www.hackerrank.com/challenges/two-pluses/problem?isFullScreen=true
Эмма квант компьютер бүтээжээ!
Түүний чадварыг шалгахад туслаарай, доорх бодлогыг шийднэ үү:

🧩 Бодлогын тайлбар: Өгөгдсөн n × m хэмжээтэй тор (grid) байна. Энэ торны бүх нүд G эсвэл B тэмдэгттэй байна: G — сайн (green) нүд, энд plus зурах боломжтой. B — муу (bad) нүд, энд юу ч зурах боломжгүй. ➕ "Plus" гэж юу вэ? Plus (нэмэх тэмдэг) гэдэг нь гол нүд-нээс дээш, доош, зүүн, баруун чиглэлд ижил урттай "гар" сунгасан хэлбэр юм. Жишээлбэл: G GGGGG G Энэ нь голдоо G тэмдэгтэй, тал бүрт 2 урттай гартай size = 2 plus юм. Нийт талбай: 4 * size + 1 = 9. 🎯 Зорилго: 2 ширхэг "plus" ол. Эдгээр нь давхцахгүй байх ёстой (аль ч нүд давхардахгүй). Тэдгээрийн талбайн үржвэр хамгийн их байх ёстой. Жишээ: Хоёр plus: нэг нь 9 талбай, нөгөө нь 5 талбай. Үржвэр: 9 * 5 = 45. ⚙️ Функцийн тодорхойлолт: int twoPluses(List grid) Параметрүүд: grid: мөрүүдийн жагсаалт. Бүх тэмдэгт G эсвэл B. ⌨️ Оролтын формат: Эхний мөрөнд 2 бүхэл тоо байна — n ба m. Дараагийн n мөр бүрт m ширхэг тэмдэгттэй string байна. 🧾 Гаралтын формат: Хамгийн том 2 plus-н талбайн үржвэрийг нэг бүхэл тоогоор хэвлэ. 🧷 Хязгаарлалт: 2 ≤ n, m ≤ 15

image
https://www.hackerrank.com/challenges/larrys-array/problem?isFullScreen=true
Орчуулга
Ларриг 1-ээс эхэлсэн дарааллын нэгэн орлуулгыг массив хэлбэрээр өгсөн. Тэрээр дараах үйлдлийг хэдэн ч удаа давтаж массивыг эрэмбэлж болох эсэхийг тодорхойлох ёстой: Үргэлжлүүлэн байрласан ямар нэгэн 3 индексийг сонгож, эдгээр гурван элементүүдийг тойруулан эргүүлэх (rotation) үйлдлийг хийх. Жишээ нь: A эргүүлэлт [1,6,5,2,4,3] [6,5,2] [1,5,2,6,4,3] [5,2,6] [1,2,6,5,4,3] [5,4,3] [1,2,6,3,5,4] [6,3,5] [1,2,3,5,6,4] [5,6,4] [1,2,3,4,5,6] Хэрэв бүх элементүүдийг эрэмбэлж чадвал (sorted array) "YES" гэж хэвлэ, үгүй бол "NO" гэж хэвлэ. Функцийн тайлбар larrysArray функц нь массив A-г параметр болгон авч, "YES" эсвэл "NO" утгыг буцаана. Оролтын формат Эхний мөрөнд туршилтын тоо t байна. Дараагийн t хос мөр бүр: Нэг мөрөнд массивын урт n Дараагийн мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоон элементүүд өгөгдөнө. Хязгаарлалт Массивын элементүүд 1-ээс n хүртэл тасралтгүй өссөн тоонууд байна. Гаралтын формат Туршилтын бүрд нэг мөрөнд "YES" эсвэл "NO" гэж хэвлэнэ.

image
https://www.hackerrank.com/challenges/almost-sorted/problem?isFullScreen=true
ОРчуулга
Өгөгдсөн бүхэл тооны массивыг зөвхөн дараах нэг үйлдлээр өсөх дарааллаар эрэмбэлж болох эсэхийг тодорхойлно уу: Хоёр элементийг солино. Нэг тасалбар хэсгийг буцааж эргүүлнэ. Үйлдлүүдийн аль нэгийг ашиглан массивыг эрэмбэлж болдог эсэхийг шалгаад, үр дүнг дараах байдлаар гаргана: Хэрвээ массив аль хэдийнээ эрэмбэлэгдсэн байвал, эхний мөрөнд yes гэж хэвлэ. Дараагийн мөрийг хэвлэх шаардлагагүй. Хэрвээ массивыг зөвхөн нэг үйлдлээр эрэмбэлж болдог бол, эхний мөрөнд yes гэж хэвлээд дараах байдлаар үргэлжлүүлнэ: Хэрвээ зөвхөн хоёр элементийг солих замаар л эрэмбэлж болох бол, хоёр дахь мөрөнд swap l r гэж хэвлэнэ. Энд l ба r нь солино гэж байгаа элементүүдийн индекс бөгөөд массивын индекс 1-ээс эхэлнэ гэж үзнэ. Харин зөвхөн тасалбар хэсгийг буцааж эргүүлэх замаар л эрэмбэлж болох бол, хоёр дахь мөрөнд reverse l r гэж хэвлэнэ. Энд l ба r нь эргүүлэх тасалбар хэсгийн эхний ба сүүлийн элементүүдийн индекс (1-ээс эхлэх) болно. Хэрвээ массивыг солих болон эргүүлэх аль аль үйлдлээр эрэмбэлж болдог бол, заавал солих (swap) үйлдлийг сонгоно. Хэрвээ массивыг эдгээр үйлдлүүдийн аль нэгээр ч эрэмбэлж болдоггүй бол эхний мөрөнд no гэж хэвлэнэ. Жишээ Массивыг эрэмбэлэхийн тулд 3 болон 4-р индекст байгаа элементийг солих буюу эсвэл тэдгээрийг буцааж эргүүлэх боломжтой. Өмнө дурдсанчлан солих үйлдлийг илүүд үздэг тул: Эхний мөрөнд: yes Хоёр дахь мөрөнд: swap 3 4 гэж хэвлэнэ. Функцийн тайлбар almostSorted функц нь дараах параметртэй: arr: бүхэл тооны массив (int arr[n]) Функц нь үр дүнг хэвлэх бөгөөд юу ч буцаахгүй. Оролтын формат Эхний мөрөнд массивын урт n байна. Дараагийн мөрөнд n ширхэг зайгаар тусгаарлагдсан бүхэл тоо байна. Хязгаарлалт Бүх элементүүд өөр хоорондоо ялгаатай байна. Гаралтын формат Хэрвээ массив аль хэдийн эрэмбэлэгдсэн бол, эхний мөрөнд yes гэж хэвлэнэ. Хэрвээ нэг үйлдлээр массивыг эрэмбэлж болдог бол эхний мөрөнд yes гэж, хоёр дахь мөрөнд swap l r эсвэл reverse l r гэж хэвлэнэ. Хэрвээ эрэмбэлж чадахгүй бол no гэж хэвлэнэ.
